"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[439],{623:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>l});var t=n(4848),i=n(8453);const o={id:"either",title:"Either"},s=void 0,a={id:"syntax/either",title:"Either",description:"Either",source:"@site/../generated-docs/target/mdoc/syntax/either.md",sourceDirName:"syntax",slug:"/syntax/either",permalink:"/docs/syntax/either",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"either",title:"Either"},sidebar:"docsSidebar",previous:{title:"Syntax",permalink:"/docs/syntax/"},next:{title:"Option",permalink:"/docs/syntax/option"}},c={},l=[{value:"Either",id:"either",level:2},{value:"Right-Biased <code>Either</code>",id:"right-biased-either",level:2},{value:"Either Constructors",id:"either-constructors",level:2},{value:"<code>leftMap</code> and <code>leftFlatMap</code>",id:"leftmap-and-leftflatmap",level:2}];function d(e){const r={code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.h2,{id:"either",children:"Either"}),"\n",(0,t.jsxs)(r.h2,{id:"right-biased-either",children:["Right-Biased ",(0,t.jsx)(r.code,{children:"Either"})]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"Either"})," in Scala prior to 2.12 is not right-biased meaning that you have to call ",(0,t.jsx)(r.code,{children:"Either.right"})," all the time if you want to use it with ",(0,t.jsx)(r.code,{children:"for-comprehension"}),"."]}),"\n",(0,t.jsx)(r.p,{children:"e.g.) Before 2.12"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:"for {\n  b <- methodReturningEither(a).right\n  c <- anotherReturningEither(b).right\n} yield c\n"})}),"\n",(0,t.jsxs)(r.p,{children:["If you use ",(0,t.jsx)(r.code,{children:"just-fp"}),", it becomes"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:"import just.fp.syntax._\n"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:"for {\n  b <- methodReturningEither(a)\n  c <- anotherReturningEither(b)\n} yield c\n"})}),"\n",(0,t.jsx)(r.p,{children:"Of course, you don't need to do it if you use Scala 2.12 or higher."}),"\n",(0,t.jsx)(r.h2,{id:"either-constructors",children:"Either Constructors"}),"\n",(0,t.jsxs)(r.p,{children:["In normal ways, if you want to create ",(0,t.jsx)(r.code,{children:"Left"})," or ",(0,t.jsx)(r.code,{children:"Right"}),", you just use the ",(0,t.jsx)(r.code,{children:"apply"})," methods of their companion objects (i.e. ",(0,t.jsx)(r.code,{children:"Left()"})," ",(0,t.jsx)(r.code,{children:"Right()"}),") A problem with this is that what these return is not ",(0,t.jsx)(r.code,{children:"Either"})," but its data, ",(0,t.jsx)(r.code,{children:"Left"})," or ",(0,t.jsx)(r.code,{children:"Right"}),"."]}),"\n",(0,t.jsxs)(r.p,{children:["You also need to specify not only type parameter for ",(0,t.jsx)(r.code,{children:"Left"})," but also the one for ",(0,t.jsx)(r.code,{children:"Right"})," when creating ",(0,t.jsx)(r.code,{children:"Right"}),"."]}),"\n",(0,t.jsx)(r.p,{children:"e.g.) Without type parameters,"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:"Right(1)\n// res0: Right[Nothing, Int] = Right(value = 1)\n"})}),"\n",(0,t.jsxs)(r.p,{children:["You don't want to have ",(0,t.jsx)(r.code,{children:"Nothing"})," there. So do it with type parameters,"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:"Right[String, Int](1)\n// res1: Right[String, Int] = Right(value = 1)\n"})}),"\n",(0,t.jsx)(r.p,{children:"So it becomes unnecessarily verbose. Right should be inferred as the compiler knows it already yet to specify the left one, you have to put both left and right parameters."}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"Left"}),", of course, has the same problem."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:'Left("error")\n// res2: Left[String, Nothing] = Left(value = "error")\n'})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:'Left[String, Int]("error")\n// res3: Left[String, Int] = Left(value = "error")\n'})}),"\n",(0,t.jsxs)(r.p,{children:["Now with ",(0,t.jsx)(r.code,{children:"just-fp"}),", it's simpler. You can use use ",(0,t.jsx)(r.code,{children:"left"})," and ",(0,t.jsx)(r.code,{children:"right"})," constructors as extension methods to the actual data values with only missing type info specified."]}),"\n",(0,t.jsx)(r.p,{children:"e.g.)"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:"1.right[String] // Now you only need to specify\n// res4: Either[String, Int] = Right(value = 1)\n"})}),"\n",(0,t.jsxs)(r.p,{children:["For ",(0,t.jsx)(r.code,{children:"Left"}),","]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:'"error".left[Int]\n// res5: Either[String, Int] = Left(value = "error")\n'})}),"\n",(0,t.jsxs)(r.h2,{id:"leftmap-and-leftflatmap",children:[(0,t.jsx)(r.code,{children:"leftMap"})," and ",(0,t.jsx)(r.code,{children:"leftFlatMap"})]}),"\n",(0,t.jsxs)(r.p,{children:["So if you Scala 2.12 or higher or ",(0,t.jsx)(r.code,{children:"just-fp"})," with the older Scala, ",(0,t.jsx)(r.code,{children:"Either"})," is right-biassed. Then what about the ",(0,t.jsx)(r.code,{children:"Left"})," case? Can I ever use ",(0,t.jsx)(r.code,{children:"Left"})," for something useful like transforming the ",(0,t.jsx)(r.code,{children:"Left"})," value to something else?"]}),"\n",(0,t.jsxs)(r.p,{children:["For that, ",(0,t.jsx)(r.code,{children:"just-fp"})," has added ",(0,t.jsx)(r.code,{children:"leftMap"})," and ",(0,t.jsx)(r.code,{children:"leftFlatMap"})," to ",(0,t.jsx)(r.code,{children:"Either"}),".\ne.g.)"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:'import just.fp.syntax._\n\nfinal case class ComputeError(error: String)\n\nsealed trait AppError\nobject AppError {\n  final case class InvalidNumberError(error: String) extends AppError\n  final case class ComputationError(computeError: ComputeError) extends AppError\n\n  def invalidNumberError(error: String): AppError =\n    InvalidNumberError(error)\n  def fromComputeError(computeError: ComputeError): AppError =\n    ComputationError(computeError)\n}\n\ndef f1(n: Int): Either[String, Int] =\n  if (n < 0)\n    Left(s"The number must be non-negative integer - n: $n")\n  else\n    Right(n)\n\ndef f2(x: Int, y: Int): Either[ComputeError, Int] = {\n  val z = x + y\n  if (x >= 0 && y >= 0 && z < 0)\n    Left(ComputeError(s"Numbers are too big - x: $x, y: $y"))\n  else\n    Right(x + y)\n}\n'})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:"for {\n  b <- f1(10).leftMap(AppError.invalidNumberError)\n  c <- f2(123, b).leftMap(AppError.fromComputeError)\n} yield c\n// res7: Either[AppError, Int] = Right(value = 133)\n"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:'for {\n  b <- f1(-1).leftMap(AppError.invalidNumberError)\n  c <- f2(123, b).leftMap(AppError.fromComputeError)\n} yield c\n// res8: Either[AppError, Int] = Left(\n//   value = InvalidNumberError(\n//     error = "The number must be non-negative integer - n: -1"\n//   )\n// )\n'})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-scala",children:'for {\n  b <- f1(Int.MaxValue).leftMap(AppError.invalidNumberError)\n  c <- f2(1, b).leftMap(AppError.fromComputeError)\n} yield c\n// res9: Either[AppError, Int] = Left(\n//   value = ComputationError(\n//     computeError = ComputeError(\n//       error = "Numbers are too big - x: 1, y: 2147483647"\n//     )\n//   )\n// )\n'})})]})}function h(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>s,x:()=>a});var t=n(6540);const i={},o=t.createContext(i);function s(e){const r=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(o.Provider,{value:r},e.children)}}}]);