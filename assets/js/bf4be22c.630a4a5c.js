"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1],{3250:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>a,contentTitle:()=>i,default:()=>u,frontMatter:()=>s,metadata:()=>c,toc:()=>p});var o=t(4848),r=t(8453);const s={id:"functor",title:"Functor"},i=void 0,c={id:"typeclass/functor",title:"Functor",description:"Functor",source:"@site/../generated-docs/target/mdoc/typeclass/functor.md",sourceDirName:"typeclass",slug:"/typeclass/functor",permalink:"/docs/typeclass/functor",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"functor",title:"Functor"},sidebar:"docsSidebar",previous:{title:"EitherT",permalink:"/docs/typeclass/either-t"},next:{title:"Monad",permalink:"/docs/typeclass/monad"}},a={},p=[{value:"Functor",id:"functor",level:2},{value:"Identity Law",id:"identity-law",level:2},{value:"Composition Law",id:"composition-law",level:2},{value:"Examples",id:"examples",level:2}];function l(n){const e={code:"code",h2:"h2",p:"p",pre:"pre",...(0,r.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.h2,{id:"functor",children:"Functor"}),"\n",(0,o.jsxs)(e.p,{children:["A ",(0,o.jsx)(e.code,{children:"functor"})," is a typeclass for the types that can be mapped over."]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.code,{children:"Functor"})," complies with identity law and composition law."]}),"\n",(0,o.jsx)(e.h2,{id:"identity-law",children:"Identity Law"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.code,{children:"map(identity) === identity"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-scala",children:"import just.fp._\nimport just.fp.syntax._\n\nFunctor[Option].map(1.some)(identity(_)) === identity(1.some)\n// res1: Boolean = true\nFunctor[Option].map(1.some)(identity(_))\n// res2: Option[Int] = Some(value = 1)\nidentity(1.some)\n// res3: Option[Int] = Some(value = 1)\n\nFunctor[Option].map(none[Int])(identity(_)) === identity(none[Int])\n// res4: Boolean = true\nFunctor[Option].map(none[Int])(identity(_))\n// res5: Option[Int] = None\nidentity(none[Int])\n// res6: Option[Int] = None\n"})}),"\n",(0,o.jsx)(e.h2,{id:"composition-law",children:"Composition Law"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.code,{children:"map(f compose g) === map(f) compose map(g)"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-scala",children:"import just.fp._\nimport just.fp.syntax._\n\nval f = (a: Int) => a + 100\n// f: Int => Int = <function1>\nval g = (b: Int) => b * 2\n// g: Int => Int = <function1>\n\nFunctor[Option].map(1.some)(f compose g)\n// res8: Option[Int] = Some(value = 102)\n\nFunctor[Option].map(Functor[Option].map(1.some)(g))(f)\n// res9: Option[Int] = Some(value = 102)\n\nFunctor[Option].map(1.some)(f compose g) ===\n  Functor[Option].map(Functor[Option].map(1.some)(g))(f)\n// res10: Boolean = true\n\n\nFunctor[Option].map(none[Int])(f compose g)\n// res11: Option[Int] = None\n\nFunctor[Option].map(Functor[Option].map(none[Int])(g))(f)\n// res12: Option[Int] = None\n\nFunctor[Option].map(none[Int])(f compose g) ===\n  Functor[Option].map(Functor[Option].map(none[Int])(g))(f)\n// res13: Boolean = true\n"})}),"\n",(0,o.jsx)(e.h2,{id:"examples",children:"Examples"}),"\n",(0,o.jsxs)(e.p,{children:["If there is a typeclass instance of ",(0,o.jsx)(e.code,{children:"Functor"})," for a type ",(0,o.jsx)(e.code,{children:"A"}),",\n",(0,o.jsx)(e.code,{children:"map"})," method can be used."]}),"\n",(0,o.jsx)(e.p,{children:"e.g.)"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-scala",children:"import just.fp._\n\nfinal case class SomeType[A](a: A)\n\nobject SomeType {\n  implicit val functorA: Functor[SomeType] = new Functor[SomeType] {\n    override def map[A, B](fa: SomeType[A])(f: A => B): SomeType[B] =\n      SomeType(f(fa.a)) \n  } \n}\n\ndef times2(someType: SomeType[Int]): SomeType[Int] = \n    implicitly[Functor[SomeType]].map(someType)(_ * 2)\n\ntimes2(SomeType(111))\n// res15: SomeType[Int] = SomeType(a = 222)\n"})}),"\n",(0,o.jsxs)(e.p,{children:["There are existing ",(0,o.jsx)(e.code,{children:"Functor"})," instances for Scala's ",(0,o.jsx)(e.code,{children:"Option"}),", ",(0,o.jsx)(e.code,{children:"Either"}),", ",(0,o.jsx)(e.code,{children:"List"}),", ",(0,o.jsx)(e.code,{children:"Vector"})," and ",(0,o.jsx)(e.code,{children:"Future"}),"."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-scala",children:'import just.fp._\nimport just.fp.syntax._  \n// just.fp.syntax._ is only for .some, none, .right, .left\n\ndef foo[A, B, F[_] : Functor](fa: F[A])(f: A => B): F[B] =\n  Functor[F].map(fa)(f)  \n  // or implicitly[Functor[F]].map(fa)(f)\n\nfoo(1.some)(_ * 2)\n// res17: Option[Int] = Some(value = 2)\nfoo(none[Int])(_ * 2)\n// res18: Option[Int] = None\n\nfoo(1.right[String])(_ * 2)\n// res19: Either[String, Int] = Right(value = 2)\nfoo("error".left[Int])(_ * 2)\n// res20: Either[String, Int] = Left(value = "error")\n\nfoo(List(1, 2, 3, 4, 5))(_ * 2)\n// res21: List[Int] = List(2, 4, 6, 8, 10)\nfoo(List.empty[Int])(_ * 2)\n// res22: List[Int] = List()\n\nfoo(Vector(1, 2, 3, 4, 5))(_ * 2)\n// res23: Vector[Int] = Vector(2, 4, 6, 8, 10)\nfoo(Vector.empty[Int])(_ * 2)\n// res24: Vector[Int] = Vector()\n\nimport scala.concurrent.Future\nimplicit val ec = scala.concurrent.ExecutionContext.global\n// ec: concurrent.ExecutionContextExecutor = scala.concurrent.impl.ExecutionContextImpl$$anon$3@28da687b[Running, parallelism = 4, size = 1, active = 0, running = 0, steals = 2, tasks = 0, submissions = 0]\n\nfoo(Future(1))(_ * 2)\n// res25: Future[Int] = Future(Success(2))\n'})})]})}function u(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(l,{...n})}):l(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>i,x:()=>c});var o=t(6540);const r={},s=o.createContext(r);function i(n){const e=o.useContext(s);return o.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:i(n.components),o.createElement(s.Provider,{value:e},n.children)}}}]);